# Αρχιτεκτονική Υπολογιστών

## Εργαστήριο 3 - Ερωτήματα Πρώτου Μέρους

Σκοπός του τρέχοντος εργαστηρίου είναι η εξοικείωση με το λογισμικό mcpat σε συνδυασμό με τις λειτουργίες του gem5, έτσι ώστε να βρούμε για κάθε πρόγραμμα που υλοποιούμε, την ενεργειακή κατανάλωση στους διάφορους επεξεργαστές που θέλουμε να το τρέξουμε αυτό.

### 1. Dynamic Power και Leakage

Στα αποτελέσματα του McPAT παρατηρούμε δύο συγκεκριμένες παραμέτρους, το `Dynamic Power` και `Leakage`.

#### Dynamic Power

To `Dynamic Power` είναι η ισχύς που καταναλώνει ένας επεξεργαστής κάθε φορά που αλλάζει το κύκλωμά του κατάσταση. Επομένως, είναι μία μεταβλητή τιμή που εξαρτάται αρκετά και από το πρόγραμμα που έχει κληθεί να τρέξει. Πιο συγκεκριμένα, η δυναμική ισχύς αποτελεί την ισχύ που δαπανάται για τη φόρτιση/εκφόρτιση των χωρητικών φορτίων κάθε φορά που το κύκλωμα αλλάζει κατάσταση. Παρατηρώντας τον παρακάτω προσεγγιστικό τύπο, μπορούμε ευκολότερα να δούμε από τι εξαρτάται η δυναμική ισχύς.

![](https://github.com/PoSeiDonTeaM/computer_architecture/blob/master/LAB3/media/P_dynamic_equation.png)

* Το C αποτελεί τη συνολική χωρητικότητα
* Το V είναι η τάση κυκλώματος (V_DD)
* Το f είναι η συχνότητα ρολογιού του επεξεργαστή μας

Επομένως, μπορούμε εύκολα να διακρίνουμε από τι εξαρτάται η δυναμική ισχύς μας.

#### Leakage

Το `Leakage` ή αλλιώς η διαρροή του κυκλώματος αποτελεί τη στατική ισχύ που καταναλώνεται λόγω διαρροής ρεύματος μέσα στο transistor. Αυτό προκύπτει από τις ατέλειες που έχουν κατά την κατασκευή τους. Επίσης το leakage χωρίζεται σε διάφορες κατηγορίες. Το `Subthreshold leakage` και το `Gate leakage`. 

To **Subthreshold leakage** παρατηρείται όταν είναι απενεργοποιημένο το transistor (κατάσταση off) που σημαίνει ότι ακόμα και όταν είναι αδρανές, μπορεί και καταναλώνει ενέργεια. Συγκεκριμένα, το transistor επιτρέπει τη διαρροή μικρού μεγέθους συνήθως ρεύματος μεταξύ του source και του drain και έτσι προκύπτει η προαναφερθούσα κατανάλωση ενέργειας.

Το **Gate leakage** αποτελεί το ρεύμα το οποίο διαρρέει από το terminal της πύλης του transistor.

### 2. Energy Efficiency

Έχουμε ένα σύστημα το οποίο τροφοδοτείται από μπαταρία συγκεκριμένης χωρητικότητας. Έχουμε στη διάθεσή μας να επιλέξουμε μεταξύ δύο επεξεργαστών. Ο ένας από αυτούς καταναλώνει **5 Watts** (Α), ενώ ο άλλος **40 Watts** (Β). Το ερώτημα που καλούμαστε να απαντήσουμε είναι αν στην περίπτωση που έχουμε μία μπαταρία με μία Χ χωρητικότητα, ποιος επεξεργαστής θα καταναλώνει περισσότερη ενέργεια και ποια επιλογή συμφέρει περισσότερο από άποψη energy efficiency. 

Η απάντηση φαντάζει να είναι απλή γιατί κατευθείαν κάποιος θα μπορούσε να πει ότι ο επεξεργαστής με τα 40 Watts καταναλώνει περισσότερη ενέργεια. Στην πραγματικότητα, ο "Β" καταναλώνει περισσότερη **ισχύ** και όχι ενέργεια. Για να υπολογίσουμε την ενεργειακή κατανάλωση χρειαζόμαστε και την παράμετρο του χρόνου για την οποία χρειάστηκε ο επεξεργαστής να τρέξει το εν λόγω πρόγραμμα. Για παράδειγμα, αν ο "Β" επεξεργαστής κάνει 5 λεπτά (300 δευτερόλεπτα) για να τρέξει το πρόγραμμα, θα καταναλώσει 12,000 J, ενώ αν ο επεξεργαστής "Α" χρειάζεται μία ώρα (3,600 δευτερόλεπτα) για να τρέξει το πρόγραμμα, τότε θα καταναλώσει 18,000 J, δραματικά περισσότερο από τον επεξεργαστή "Β". 

Επομένως, σύμφωνα με τα παραπάνω, για να μπορούμε να βγάλουμε πόρισμα για την ενεργειακή κατανάλωση χρειαζόμαστε μόνο την ισχύ που καταναλώνει ο επεξεργαστής και το χρόνο που τρέχει το πρόγραμμα. Λάθος. Πρέπει να λαμβάνουμε υπόψη μας και το Total Leakage που αναφέραμε παραπάνω. Γιατί, ακόμα και αν ο επεξεργαστής μας τρέχει πολύ πιο γρήγορα το πρόγραμμα, αν το total leakage του είναι συγκριτικά μεγαλύτερο από τον άλλο επεξεργαστή, τότε η ενεργειακή του κατανάλωση αυξάνεται επίσης δραματικά και πάντα όταν σχεδιάζουμε και επιλέγουμε το harware που πρέπει να χρησιμοποιήσουμε, πρέπει να τα λαμβάνουμε όλα αυτά υπόψη.

### 3. Σύγκριση Xeon και ARM A9

Το συγκεκριμένο ερώτημα απαντάται εν μέρει και στην απάντηση του ερωτήματος 2, καθώς αποτελεί παρόμοια φιλοσοφία. Έχουμε κάνει την υπόθεση ότι ο επεξεργαστής επεξεργαστής Xeon μπορεί να τρέξει το ίδιο πρόγραμμα με τον επεξεργαστή ARM A9 έως και 40 φορές γρηγορότερα. Ακόμα και με αυτή την υπόθεση καλούμαστε να εξετάσουμε αν ο Xeon είναι ενεργειακά αποδοτικότερος από τον ARM A9. Παρακάτω παρατηρούμε τα benchmarks που έχουν αποτυπωθεί στην οθόνη μας για τους δύο επεξεργαστές.

#### Xeon:

~~~
Processor:
  Area = 410.507 mm^2
  Peak Power = 134.938 W
  Total Leakage = 36.8319 W
  Peak Dynamic = 98.1063 W
  Subthreshold Leakage = 35.1632 W
  Subthreshold Leakage with power gating = 16.3977 W
  Gate Leakage = 1.66871 W
  Runtime Dynamic = 72.9199 W
~~~

#### ARM A9:

~~~
Processor:
  Area = 5.39698 mm^2
  Peak Power = 1.74189 W
  Total Leakage = 0.108687 W
  Peak Dynamic = 1.6332 W
  Subthreshold Leakage = 0.0523094 W
  Gate Leakage = 0.0563774 W
  Runtime Dynamic = 2.96053 W
~~~

Η διαφορά στην κατανάλωση ισχύος είναι δραματικά μεγαλύτερη στον Xeon επεξεργαστή. Αυτό όμως που παίζει στην παρούσα περίπτωση το μεγαλύτερο ρόλο στο energy efficiency είναι το Total Leakage του Xeon, το οποίο υπερισχύει. Συγκεκριμένα, το Total Leakage του Xeon είναι 21 φορές μεγαλύτερο από το Peak Power του ARM A9 που σημαίνει ότι ακόμα και αν το κύκλωμα είναι σε λειτουργία "OFF" καταναλώνει 21 φορές παραπάνω ενέργεια από τον ARM A9 όσο αυτός είναι σε κανονική λειτουργία. Σε καμία περίπτωση λοιπόν δεν μπορεί να είναι ενεργειακά πιο αποδοτικός ο Xeon, ακόμα και αν είναι 40 φορές γρηγορότερος.

## Δεύτερο μέρος

Προτού απαντηθούν τα ερωτήματα, είναι κρίσιμο να αναφερθεί ότι για την αυτοματοποίηση της διαδικασίας χρησιμοποιήθηκαν διάφορα bash scripts `.sh` προκειμένου να τρέξουμε πολλές εντολές χωρίς απαραίτητα να χρειάζεται να επιβλέπουμε τη διαδικασία. Τα scripts μπορούν να χρησιμοποιηθούν από τον οποιονδήποτε αρκετά εύκολα, αρκεί να αλλαχτεί το directory που είναι τοποθετημένος ο gem5. Για κάποιον ο οποίος θέλει να ελέγχει τα αποτελέσματα κάθε φορά που τελειώνει μία διεργασία, χρησιμοποιείται ένα αρχείο `.wav` προκειμένου να δημιουργεί έναν ήχο ειδοποίησης που υποδηλώνει ότι η συγκεκριμένη διεργασία τελείωσε και το αρχείο αποθηκεύτηκε επιτυχώς.

### 1. Άντληση πληροφοριών από τα scripts

Χρησιμοποιώντας τα αρχεία `.xml` που δημιουργήσαμε, μπορούμε εύκολα να αντλήσουμε την πληροφορία όσον αφορά το area (αθροίζοντας το area του core με το L2 area). Την πληροφορία για το delay μπορούμε να την αντλήσουμε από το αρχείο `config.json` από την παράμετρο **sim_seconds**. Η ενέργεια προκύπτει χρησιμοποιώντας το python script `print-energy.py` , το xml αρχείο που δημιουργήσαμε και το `config.txt` αρχείο. 

### 2. Γραφήματα

Για τη δημιουργία γραφημάτων, δημιουργήσαμε ένα αρχείο excel στο οποίο τοποθετήθηκε όλη η πληροφορία που αντλήθηκε από τα παραπάνω ερωτήματα αλλά και από το προηγούμενο εργαστήριο. Με τη χρήση του λογισμικού Matlab δημιουργήσαμε το αρχείο `plots.m` το οποίο εισάγει τα δεδομένα από το excel μας, περνάει τις τιμές σε έναν δισδιάστατο πίνακα και μας επιτρέπει να ανατρέχουμε εύκολα σε οποιαδήποτε τιμή του πίνακα επιθυμούμε. Στο αρχείο εμπεριέχεται ο κώδικας για όλα τα plots που έχουμε κατασκευάσει.

Τα γραφήματα έχουν δημιουργηθεί με διαφορετικές επιλογές όσον αφορά το hardware για να μπορούμε να τα συγκρίνουμε καλύτερα. 

#### Αποτελέσματα:

**A.** Για τα παρακάτω γραφήματα χρησιμοποιήθηκαν τα νούμερα 1 έως 3:

| no | l1d_size | l1i_size | l2_size | l1i_associativity | l1d_associativity | l2_associativity | cacheline_size |
|----|----------|----------|---------|-------------------|-------------------|------------------|----------------|
| 1  | 32       | 64       | 512     | 1                 | 1                 | 2                | 64             |
| 2  | 64       | 64       | 1024    | 1                 | 1                 | 2                | 64             |
| 3  | 128      | 64       | 1024    | 1                 | 1                 | 2                | 64             | 

![](https://github.com/PoSeiDonTeaM/computer_architecture/blob/master/LAB3/media/plots/l1d-size-area.png)

![](https://github.com/PoSeiDonTeaM/computer_architecture/blob/master/LAB3/media/plots/l1d-size-energy.png)

Παρατηρούμε ότι όσο αυξάνεται το μέγεθος της l1D τόσο αυξάνεται και η ενέργεια αλλά και η περιοχή.

**Β.** Για τα παρακάτω γραφήματα χρησιμοποιήθηκαν τα νούμερα 4 έως 6:

| no | l1d_size | l1i_size | l2_size | l1i_associativity | l1d_associativity | l2_associativity | cacheline_size |
|----|----------|----------|---------|-------------------|-------------------|------------------|----------------|
| 4  | 128      | 128      | 1024    | 1                 | 1                 | 2                | 64             |
| 5  | 128      | 128      | 2048    | 1                 | 1                 | 2                | 64             |
| 6  | 128      | 128      | 4096    | 1                 | 1                 | 2                | 64             |

![](https://github.com/PoSeiDonTeaM/computer_architecture/blob/master/LAB3/media/plots/l2-size-area.png)

![](https://github.com/PoSeiDonTeaM/computer_architecture/blob/master/LAB3/media/plots/l2-size-energy.png)

Παρατηρούμε παρόμοια αύξηση με τα προηγούμενα γραφήματα, αλλά η αύξηση στην ενέργεια και την περιοχή αυξάνοντας το μέγεθος του l2 φαίνεται ότι είναι δραματικά μεγαλύτερη. 

**Γ.** Για τα παρακάτω γραφήματα χρησιμοποιήθηκαν τα νούμερα 7 έως 8:

| no | l1d_size | l1i_size | l2_size | l1i_associativity | l1d_associativity | l2_associativity | cacheline_size |
|----|----------|----------|---------|-------------------|-------------------|------------------|----------------|
| 7  | 32       | 64       | 512     | 2                 | 2                 | 2                | 64             |
| 8  | 64       | 64       | 512     | 4                 | 4                 | 2                | 64             |

![](https://github.com/PoSeiDonTeaM/computer_architecture/blob/master/LAB3/media/plots/l1d-size-area-2.png)

![](https://github.com/PoSeiDonTeaM/computer_architecture/blob/master/LAB3/media/plots/l1d-size-energy-2.png)

Η συγκεκριμένη αρχιτεκτονική είναι παρόμοια με την αρχιτεκτονική **Α**, αλλά με υποδιπλασιασμένο το μέγεθος του l2. Παρατηρούμε ότι υποδιπλασιάζοντας το μέγεθος του l2 έχουμε πάλι αύξηση στην ενέργεια και στην περιοχή αλλά είναι συγκριτικά μικρότερη αυτή τη φορά. Μπορούμε να βγάλουμε λοιπόν το συμπέρασμα εύκολα ότι συμφέρει ενεργειακά και οικονομικά να προσθέσουμε στο σύστημά μας μικρότερο μέγεθος l2 cache και να έχουμε ίδια αποτελέσματα όσον αφορά το χρόνο απόκρισης.

**Δ.** Για τα παρακάτω γραφήματα χρησιμοποίηθηκαν τα νούμερα 13 έως 15:

| no | l1d_size | l1i_size | l2_size | l1i_associativity | l1d_associativity | l2_associativity | cacheline_size |
|----|----------|----------|---------|-------------------|-------------------|------------------|----------------|
| 13 | 32       | 64       | 512     | 8                 | 8                 | 8                | 64             |
| 14 | 64       | 128      | 1024    | 8                 | 8                 | 8                | 64             |
| 15 | 128      | 128      | 2048    | 8                 | 8                 | 8                | 64             |

![](https://github.com/PoSeiDonTeaM/computer_architecture/blob/master/LAB3/media/plots/l1d-l2-size-area.png)

![](https://github.com/PoSeiDonTeaM/computer_architecture/blob/master/LAB3/media/plots/l1d-l2-size-energy.png)

Προηγουμένως είδαμε ότι όσο μεγαλύτερο ήταν το μέγεθος του l2 τόσο μεγαλύτερη ήταν η ενεργειακή κατανάλωση. Τα αποτελέσματα όμως εκείνα ήταν για χαμηλό associativity των l1 και l2. Αυξάνοντας το associativity λοιπόν παρατηρούμε ότι ακόμα κι αν μεγαλώσουμε το μέγεθος του l2, η ενεργειακή κατανάλωση είναι αρκετά μικρότερη από το προηγούμενο configuration μας. Παρόλο αυτά, το μέγεθος παραμένει ιδιαίτερα αυξημένο κάτι το οποίο μας στοιχίζει.

### 3. Σχολιασμός συνάρτησης κόστους

Η συνάρτηση κόστους φαίνεται να λειτουργεί επιτυχώς, η οποία μας διαμορφώνει εύκολα και γρήγορα το επιθυμητό configuration μας επιλέγοντας τα ιδανικά μεγέθη (και τις υπόλοιπες παραμέτρους) για τις l1 και l2 caches μας. Με αυτόν τον τρόπο μπορούμε να κρατήσουμε την ενεργειακή μας κατανάλωση στο minimum και να έχουμε μικρές αποκλίσεις στα αποτελέσματά μας. 

## Κριτική

Η συγκεκριμένη εργασία ήταν ίσως η πιο ενδιαφέρουσα και από τις προηγούμενες δύο καθώς συνδύαζε πολλαπλά προβλήματα (simulation time, area, power consumption, energy) και μας βοήθησε να μπούμε στη λογική του "αρχιτέκτονα" υπολογιστών και κληθήκαμε να σκεφτούμε το κόστος που θα έχει η επιλογή του hardware μας είτε αυτό είναι ενεργειακό είτε είναι οικονομικό είτε σε χρόνο απόκρισης. 

Κάτι που ίσως θα έπρεπε να είχε προβλεφθεί για τη συγκεκριμένη εργασία είναι τα τρισδιάστατα γραφήματα. Αν μπορούσαμε με κάποιον τρόπο να αναπαραστήσουμε τα γραφήματα στον τρισδιάστατο χώρο ίσως ήταν πιο ευδιάκριτα για τον αναγνώστη. 

Θα θέλαμε επίσης να δούμε και την παράμετρο της θερμοκρασίας που στα μικροηλεκτρονικά είναι ιδιαίτερα σημαντική. Μπορεί εμείς να επιλέγουμε αυτή τη στιγμή το hardware μας για το πρόγραμμα που θέλουμε να τρέχει το configuration μας, αλλά δεν έχουμε λάβει υπόψη μας τη θερμοκρασία η οποία μπορεί πολύ εύκολα να αλλάξει τον τρόπο επιλογής.

Ίσως θα μπορούσε να μπει μία έξτρα εργασία προσθετική και προαιρετική χωρίς να υπάρχει απαραίτητα 4ο εργαστήριο κατά την οποία θα κληθούμε να γράψουμε ένα πρόγραμμα σε C σε κάποιον μικροελεγκτή και θα πρέπει να επιλέξουμε το hardware μας και κάνοντας κάποιες βελτιστοποιήσεις με τη συνάρτηση κόστους που δημιουργήσαμε με πραγματικά δεδομένα. Για παράδειγμα, θα μπορούσαμε να έχουμε μία επιχείρηση η οποία θα πρέπει να επιλέξει ένα configuration προκειμένου να τρέχει ένα συγκεκριμένο πρόγραμμα για έναν αριθμό από υπολογιστές. Θα μας δίνεται η τιμή του κόστους για 1kW από τον πάροχο ηλεκτρική ενέργειας και θα έπρεπε να διαμορφώσουμε ένα configuration με το λιγότερο δυνατό οικονομικό κόστος αλλά και με τη μεγαλύτερη δυνατή διάρκεια ζωής. Θα ήταν κάτι ιδιαίτερα ενδιαφέρον να κληθούμε να απαντήσουμε σε ένα πραγματικό πρόβλημα μηχανικού και να μπούμε έμπρακτα στο ρόλο αυτού.
